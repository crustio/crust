// x in [1, 330] to represent 0.1% -> 33%
// inverse function: r = 0.33 / x - 0.65
// use x-0.0005 as the sample index
fn inverse_function(x: u32) -> (u32, f64) {
    let real_x = (x as f64 / 1000 as f64) - 0.0005;
    let r = 0.33 / real_x - 0.65;
    let integer = r as u32;
    let frac = r - integer as f64;
    (integer, frac)
}


fn calculate_parameter_table() -> Vec<(u32, u32, u32, f64)>{
    let mut parameters = vec![];
    for x in 1..331 {
        let start = (x - 1) * 1_000;
        let end = x * 1_000 - 1;
        let (integer, frac) = inverse_function(x);
        parameters.push((start, end, integer, frac));
    }
    parameters
}

fn add_head_comment() {
    println!("/// This is autogenerated by script. Please don't directly change it.");
    println!("/// Under the utils/inverse-function folder,");
    println!("/// Run `cargo run > ../../cstrml/staking/src/total_stake_limit_ratio.rs`");
}

fn add_import() {
    println!("use sp_runtime::{{Perbill, Permill}};");
}

fn generate_one_condition_line(start: u32, end: u32, integer: u32, frac: f64) {
    let frac_part = (frac.max(0.).min(1.) * 1_000_000_000f64) as u32;
    println!("        {} ..= {} => ({}, Perbill::from_parts({})),", start, end, integer, frac_part);
}

fn generate_default_condition_line() {
    println!("       _ => (0, Perbill::from_parts(350_000_000))");
}

fn generate_function() {
    println!("pub fn total_stake_limit_ratio(effective_stake_ratio: Permill) -> (u32, Perbill) {{");
    println!("    match effective_stake_ratio.deconstruct() {{");

    let parameters_table = calculate_parameter_table();
    for para in parameters_table {
        generate_one_condition_line(para.0, para.1, para.2, para.3);
    }

    generate_default_condition_line();
    println!("    }}");
    println!("}}");
}

fn main() {
    add_head_comment();
    println!("");
    add_import();
    println!("");
    generate_function();
}
